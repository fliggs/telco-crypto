/* tslint:disable */
/* eslint-disable */
/**
 * Fliggs
 * This is our cool new API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddressType,
  ChangeMyAddressDto,
  CreateMyOrderDto,
  CreateMyWalletDto,
  OrderStatus,
  OrderType,
  PublicAddressDto,
  PublicCertificateDto,
  PublicInvoiceWithOrderAndItemsDto,
  PublicMeDto,
  PublicOfferWithPlanWithVolumesDto,
  PublicOnboardingProgressDto,
  PublicOrderDto,
  PublicOrderWithDetailsDto,
  PublicOrderWithOfferDto,
  PublicSessionTokensDto,
  PublicSigningRequestDto,
  PublicSimDetailsDto,
  PublicSubscriptionDto,
  PublicSubscriptionPeriodWithOfferDto,
  PublicSubscriptionWithOfferDto,
  PublicTaxItemDto,
  PublicTokenBalanceDto,
  PublicTokenHistoryDto,
  PublicVolumeUsageDto,
  PublicWalletDto,
  UpdateMeDto,
  UpdateMyOnboardingProgressDto,
  UpdateMyOrderDto,
  UpdateMyOrderStepAttachSimDto,
  UpdateMyOrderStepSignDto,
  UpdateMyOrderV2Dto,
  UpdateMySubscriptionDto,
  UpdateMyWalletDto,
  ValidateMyWalletDto,
} from '../models/index';
import {
    AddressTypeFromJSON,
    AddressTypeToJSON,
    ChangeMyAddressDtoFromJSON,
    ChangeMyAddressDtoToJSON,
    CreateMyOrderDtoFromJSON,
    CreateMyOrderDtoToJSON,
    CreateMyWalletDtoFromJSON,
    CreateMyWalletDtoToJSON,
    OrderStatusFromJSON,
    OrderStatusToJSON,
    OrderTypeFromJSON,
    OrderTypeToJSON,
    PublicAddressDtoFromJSON,
    PublicAddressDtoToJSON,
    PublicCertificateDtoFromJSON,
    PublicCertificateDtoToJSON,
    PublicInvoiceWithOrderAndItemsDtoFromJSON,
    PublicInvoiceWithOrderAndItemsDtoToJSON,
    PublicMeDtoFromJSON,
    PublicMeDtoToJSON,
    PublicOfferWithPlanWithVolumesDtoFromJSON,
    PublicOfferWithPlanWithVolumesDtoToJSON,
    PublicOnboardingProgressDtoFromJSON,
    PublicOnboardingProgressDtoToJSON,
    PublicOrderDtoFromJSON,
    PublicOrderDtoToJSON,
    PublicOrderWithDetailsDtoFromJSON,
    PublicOrderWithDetailsDtoToJSON,
    PublicOrderWithOfferDtoFromJSON,
    PublicOrderWithOfferDtoToJSON,
    PublicSessionTokensDtoFromJSON,
    PublicSessionTokensDtoToJSON,
    PublicSigningRequestDtoFromJSON,
    PublicSigningRequestDtoToJSON,
    PublicSimDetailsDtoFromJSON,
    PublicSimDetailsDtoToJSON,
    PublicSubscriptionDtoFromJSON,
    PublicSubscriptionDtoToJSON,
    PublicSubscriptionPeriodWithOfferDtoFromJSON,
    PublicSubscriptionPeriodWithOfferDtoToJSON,
    PublicSubscriptionWithOfferDtoFromJSON,
    PublicSubscriptionWithOfferDtoToJSON,
    PublicTaxItemDtoFromJSON,
    PublicTaxItemDtoToJSON,
    PublicTokenBalanceDtoFromJSON,
    PublicTokenBalanceDtoToJSON,
    PublicTokenHistoryDtoFromJSON,
    PublicTokenHistoryDtoToJSON,
    PublicVolumeUsageDtoFromJSON,
    PublicVolumeUsageDtoToJSON,
    PublicWalletDtoFromJSON,
    PublicWalletDtoToJSON,
    UpdateMeDtoFromJSON,
    UpdateMeDtoToJSON,
    UpdateMyOnboardingProgressDtoFromJSON,
    UpdateMyOnboardingProgressDtoToJSON,
    UpdateMyOrderDtoFromJSON,
    UpdateMyOrderDtoToJSON,
    UpdateMyOrderStepAttachSimDtoFromJSON,
    UpdateMyOrderStepAttachSimDtoToJSON,
    UpdateMyOrderStepSignDtoFromJSON,
    UpdateMyOrderStepSignDtoToJSON,
    UpdateMyOrderV2DtoFromJSON,
    UpdateMyOrderV2DtoToJSON,
    UpdateMySubscriptionDtoFromJSON,
    UpdateMySubscriptionDtoToJSON,
    UpdateMyWalletDtoFromJSON,
    UpdateMyWalletDtoToJSON,
    ValidateMyWalletDtoFromJSON,
    ValidateMyWalletDtoToJSON,
} from '../models/index';

export interface MeChangeMyAddressV1Request {
    type: AddressType;
    changeMyAddressDto: ChangeMyAddressDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeCreateMyOrderV1Request {
    createMyOrderDto: CreateMyOrderDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeCreateMyWalletV1Request {
    createMyWalletDto: CreateMyWalletDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeDeleteMySubscriptionV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMeV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyAddressV1Request {
    type: AddressType;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyAddressesV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyInvoicesV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOnboardingProgressV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOrderTaxesV1Request {
    orderId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOrderV1Request {
    orderId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOrderV2Request {
    orderId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOrdersV1Request {
    types?: Array<OrderType>;
    status?: Array<OrderStatus>;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyOrdersV2Request {
    status?: Array<OrderStatus>;
    type?: Array<OrderType>;
    step?: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionActiveSimDetailsV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionActiveSimUsageV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionChildrenV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionOffersV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionOrdersV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionPeriodsV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMySubscriptionsV1Request {
    baseOnly?: boolean;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyWalletCertificatesV1Request {
    walletIdOrAddress: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyWalletTokensV1Request {
    walletIdOrAddress: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeFindMyWalletsV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeGetCreditBalanceV1Request {
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeGetMySigningRequestV1Request {
    walletIdOrAddress: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeGetMyWalletTokenHistoryV1Request {
    walletIdOrAddress: string;
    token: string;
    days?: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUncancelMySubscriptionV1Request {
    subId: string;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMeV1Request {
    updateMeDto: UpdateMeDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOnboardingProgressV1Request {
    updateMyOnboardingProgressDto: UpdateMyOnboardingProgressDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderSimSelectionV1Request {
    orderId: string;
    updateMyOrderStepAttachSimDto: UpdateMyOrderStepAttachSimDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderStepAttachSimV1Request {
    orderId: string;
    stepId: string;
    updateMyOrderStepAttachSimDto: UpdateMyOrderStepAttachSimDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderStepSignV1Request {
    orderId: string;
    updateMyOrderStepSignDto: UpdateMyOrderStepSignDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderV1Request {
    orderId: string;
    updateMyOrderDto: UpdateMyOrderDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderV2Request {
    orderId: string;
    updateMyOrderV2Dto: UpdateMyOrderV2Dto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyOrderV3Request {
    orderId: string;
    updateMyOrderV2Dto: UpdateMyOrderV2Dto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMySubscriptionV1Request {
    subId: string;
    updateMySubscriptionDto: UpdateMySubscriptionDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeUpdateMyWalletV1Request {
    walletIdOrAddress: string;
    updateMyWalletDto: UpdateMyWalletDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

export interface MeValidateMyWalletV1Request {
    walletIdOrAddress: string;
    validateMyWalletDto: ValidateMyWalletDto;
    xAuthProvider?: string;
    xAuthStrategy?: string;
}

/**
 * MeApi - interface
 * 
 * @export
 * @interface MeApiInterface
 */
export interface MeApiInterface {
    /**
     * 
     * @param {AddressType} type 
     * @param {ChangeMyAddressDto} changeMyAddressDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meChangeMyAddressV1Raw(requestParameters: MeChangeMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicAddressDto>>;

    /**
     */
    meChangeMyAddressV1(requestParameters: MeChangeMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicAddressDto>;

    /**
     * 
     * @param {CreateMyOrderDto} createMyOrderDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meCreateMyOrderV1Raw(requestParameters: MeCreateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     */
    meCreateMyOrderV1(requestParameters: MeCreateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @param {CreateMyWalletDto} createMyWalletDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meCreateMyWalletV1Raw(requestParameters: MeCreateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicWalletDto>>;

    /**
     */
    meCreateMyWalletV1(requestParameters: MeCreateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicWalletDto>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meDeleteMySubscriptionV1Raw(requestParameters: MeDeleteMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>>;

    /**
     */
    meDeleteMySubscriptionV1(requestParameters: MeDeleteMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMeV1Raw(requestParameters: MeFindMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicMeDto>>;

    /**
     */
    meFindMeV1(requestParameters: MeFindMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicMeDto>;

    /**
     * 
     * @param {AddressType} type 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyAddressV1Raw(requestParameters: MeFindMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicAddressDto>>;

    /**
     */
    meFindMyAddressV1(requestParameters: MeFindMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicAddressDto>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyAddressesV1Raw(requestParameters: MeFindMyAddressesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicAddressDto>>>;

    /**
     */
    meFindMyAddressesV1(requestParameters: MeFindMyAddressesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicAddressDto>>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyInvoicesV1Raw(requestParameters: MeFindMyInvoicesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicInvoiceWithOrderAndItemsDto>>>;

    /**
     */
    meFindMyInvoicesV1(requestParameters: MeFindMyInvoicesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicInvoiceWithOrderAndItemsDto>>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOnboardingProgressV1Raw(requestParameters: MeFindMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOnboardingProgressDto>>>;

    /**
     */
    meFindMyOnboardingProgressV1(requestParameters: MeFindMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOnboardingProgressDto>>;

    /**
     * 
     * @param {string} orderId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOrderTaxesV1Raw(requestParameters: MeFindMyOrderTaxesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicTaxItemDto>>>;

    /**
     */
    meFindMyOrderTaxesV1(requestParameters: MeFindMyOrderTaxesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicTaxItemDto>>;

    /**
     * 
     * @summary 
     * @param {string} orderId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOrderV1Raw(requestParameters: MeFindMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     * 
     * @deprecated
     */
    meFindMyOrderV1(requestParameters: MeFindMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @param {string} orderId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOrderV2Raw(requestParameters: MeFindMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>>;

    /**
     */
    meFindMyOrderV2(requestParameters: MeFindMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto>;

    /**
     * 
     * @summary 
     * @param {Array<OrderType>} [types] 
     * @param {Array<OrderStatus>} [status] 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOrdersV1Raw(requestParameters: MeFindMyOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderWithOfferDto>>>;

    /**
     * 
     * @deprecated
     */
    meFindMyOrdersV1(requestParameters: MeFindMyOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderWithOfferDto>>;

    /**
     * 
     * @param {Array<OrderStatus>} [status] 
     * @param {Array<OrderType>} [type] 
     * @param {string} [step] 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyOrdersV2Raw(requestParameters: MeFindMyOrdersV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderDto>>>;

    /**
     */
    meFindMyOrdersV2(requestParameters: MeFindMyOrdersV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionActiveSimDetailsV1Raw(requestParameters: MeFindMySubscriptionActiveSimDetailsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSimDetailsDto>>;

    /**
     */
    meFindMySubscriptionActiveSimDetailsV1(requestParameters: MeFindMySubscriptionActiveSimDetailsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSimDetailsDto>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionActiveSimUsageV1Raw(requestParameters: MeFindMySubscriptionActiveSimUsageV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicVolumeUsageDto>>>;

    /**
     */
    meFindMySubscriptionActiveSimUsageV1(requestParameters: MeFindMySubscriptionActiveSimUsageV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicVolumeUsageDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionChildrenV1Raw(requestParameters: MeFindMySubscriptionChildrenV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionWithOfferDto>>>;

    /**
     */
    meFindMySubscriptionChildrenV1(requestParameters: MeFindMySubscriptionChildrenV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionWithOfferDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionOffersV1Raw(requestParameters: MeFindMySubscriptionOffersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOfferWithPlanWithVolumesDto>>>;

    /**
     */
    meFindMySubscriptionOffersV1(requestParameters: MeFindMySubscriptionOffersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOfferWithPlanWithVolumesDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionOrdersV1Raw(requestParameters: MeFindMySubscriptionOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderWithOfferDto>>>;

    /**
     */
    meFindMySubscriptionOrdersV1(requestParameters: MeFindMySubscriptionOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderWithOfferDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionPeriodsV1Raw(requestParameters: MeFindMySubscriptionPeriodsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionPeriodWithOfferDto>>>;

    /**
     */
    meFindMySubscriptionPeriodsV1(requestParameters: MeFindMySubscriptionPeriodsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionPeriodWithOfferDto>>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionV1Raw(requestParameters: MeFindMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionWithOfferDto>>;

    /**
     */
    meFindMySubscriptionV1(requestParameters: MeFindMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionWithOfferDto>;

    /**
     * 
     * @param {boolean} [baseOnly] 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMySubscriptionsV1Raw(requestParameters: MeFindMySubscriptionsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionWithOfferDto>>>;

    /**
     */
    meFindMySubscriptionsV1(requestParameters: MeFindMySubscriptionsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionWithOfferDto>>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyWalletCertificatesV1Raw(requestParameters: MeFindMyWalletCertificatesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicCertificateDto>>>;

    /**
     */
    meFindMyWalletCertificatesV1(requestParameters: MeFindMyWalletCertificatesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicCertificateDto>>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyWalletTokensV1Raw(requestParameters: MeFindMyWalletTokensV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicTokenBalanceDto>>>;

    /**
     */
    meFindMyWalletTokensV1(requestParameters: MeFindMyWalletTokensV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicTokenBalanceDto>>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meFindMyWalletsV1Raw(requestParameters: MeFindMyWalletsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicWalletDto>>>;

    /**
     */
    meFindMyWalletsV1(requestParameters: MeFindMyWalletsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicWalletDto>>;

    /**
     * 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meGetCreditBalanceV1Raw(requestParameters: MeGetCreditBalanceV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     */
    meGetCreditBalanceV1(requestParameters: MeGetCreditBalanceV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meGetMySigningRequestV1Raw(requestParameters: MeGetMySigningRequestV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSigningRequestDto>>;

    /**
     */
    meGetMySigningRequestV1(requestParameters: MeGetMySigningRequestV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSigningRequestDto>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {string} token 
     * @param {string} [days] 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meGetMyWalletTokenHistoryV1Raw(requestParameters: MeGetMyWalletTokenHistoryV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicTokenHistoryDto>>;

    /**
     */
    meGetMyWalletTokenHistoryV1(requestParameters: MeGetMyWalletTokenHistoryV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicTokenHistoryDto>;

    /**
     * 
     * @param {string} subId 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUncancelMySubscriptionV1Raw(requestParameters: MeUncancelMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>>;

    /**
     */
    meUncancelMySubscriptionV1(requestParameters: MeUncancelMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto>;

    /**
     * 
     * @param {UpdateMeDto} updateMeDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMeV1Raw(requestParameters: MeUpdateMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSessionTokensDto>>;

    /**
     */
    meUpdateMeV1(requestParameters: MeUpdateMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSessionTokensDto>;

    /**
     * 
     * @param {UpdateMyOnboardingProgressDto} updateMyOnboardingProgressDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOnboardingProgressV1Raw(requestParameters: MeUpdateMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     */
    meUpdateMyOnboardingProgressV1(requestParameters: MeUpdateMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @param {string} orderId 
     * @param {UpdateMyOrderStepAttachSimDto} updateMyOrderStepAttachSimDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderSimSelectionV1Raw(requestParameters: MeUpdateMyOrderSimSelectionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     */
    meUpdateMyOrderSimSelectionV1(requestParameters: MeUpdateMyOrderSimSelectionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @param {string} orderId 
     * @param {string} stepId 
     * @param {UpdateMyOrderStepAttachSimDto} updateMyOrderStepAttachSimDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderStepAttachSimV1Raw(requestParameters: MeUpdateMyOrderStepAttachSimV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     */
    meUpdateMyOrderStepAttachSimV1(requestParameters: MeUpdateMyOrderStepAttachSimV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @param {string} orderId 
     * @param {UpdateMyOrderStepSignDto} updateMyOrderStepSignDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderStepSignV1Raw(requestParameters: MeUpdateMyOrderStepSignV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>>;

    /**
     */
    meUpdateMyOrderStepSignV1(requestParameters: MeUpdateMyOrderStepSignV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto>;

    /**
     * 
     * @summary 
     * @param {string} orderId 
     * @param {UpdateMyOrderDto} updateMyOrderDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderV1Raw(requestParameters: MeUpdateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     * 
     * @deprecated
     */
    meUpdateMyOrderV1(requestParameters: MeUpdateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @summary 
     * @param {string} orderId 
     * @param {UpdateMyOrderV2Dto} updateMyOrderV2Dto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderV2Raw(requestParameters: MeUpdateMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>>;

    /**
     * 
     * @deprecated
     */
    meUpdateMyOrderV2(requestParameters: MeUpdateMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto>;

    /**
     * 
     * @param {string} orderId 
     * @param {UpdateMyOrderV2Dto} updateMyOrderV2Dto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyOrderV3Raw(requestParameters: MeUpdateMyOrderV3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>>;

    /**
     */
    meUpdateMyOrderV3(requestParameters: MeUpdateMyOrderV3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto>;

    /**
     * 
     * @param {string} subId 
     * @param {UpdateMySubscriptionDto} updateMySubscriptionDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMySubscriptionV1Raw(requestParameters: MeUpdateMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>>;

    /**
     */
    meUpdateMySubscriptionV1(requestParameters: MeUpdateMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {UpdateMyWalletDto} updateMyWalletDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meUpdateMyWalletV1Raw(requestParameters: MeUpdateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicWalletDto>>;

    /**
     */
    meUpdateMyWalletV1(requestParameters: MeUpdateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicWalletDto>;

    /**
     * 
     * @param {string} walletIdOrAddress 
     * @param {ValidateMyWalletDto} validateMyWalletDto 
     * @param {string} [xAuthProvider] 
     * @param {string} [xAuthStrategy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meValidateMyWalletV1Raw(requestParameters: MeValidateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>>;

    /**
     */
    meValidateMyWalletV1(requestParameters: MeValidateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean>;

}

/**
 * 
 */
export class MeApi extends runtime.BaseAPI implements MeApiInterface {

    /**
     */
    async meChangeMyAddressV1Raw(requestParameters: MeChangeMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicAddressDto>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling meChangeMyAddressV1().'
            );
        }

        if (requestParameters['changeMyAddressDto'] == null) {
            throw new runtime.RequiredError(
                'changeMyAddressDto',
                'Required parameter "changeMyAddressDto" was null or undefined when calling meChangeMyAddressV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/addresses/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ChangeMyAddressDtoToJSON(requestParameters['changeMyAddressDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicAddressDtoFromJSON(jsonValue));
    }

    /**
     */
    async meChangeMyAddressV1(requestParameters: MeChangeMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicAddressDto> {
        const response = await this.meChangeMyAddressV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meCreateMyOrderV1Raw(requestParameters: MeCreateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['createMyOrderDto'] == null) {
            throw new runtime.RequiredError(
                'createMyOrderDto',
                'Required parameter "createMyOrderDto" was null or undefined when calling meCreateMyOrderV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMyOrderDtoToJSON(requestParameters['createMyOrderDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     */
    async meCreateMyOrderV1(requestParameters: MeCreateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meCreateMyOrderV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meCreateMyWalletV1Raw(requestParameters: MeCreateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicWalletDto>> {
        if (requestParameters['createMyWalletDto'] == null) {
            throw new runtime.RequiredError(
                'createMyWalletDto',
                'Required parameter "createMyWalletDto" was null or undefined when calling meCreateMyWalletV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMyWalletDtoToJSON(requestParameters['createMyWalletDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicWalletDtoFromJSON(jsonValue));
    }

    /**
     */
    async meCreateMyWalletV1(requestParameters: MeCreateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicWalletDto> {
        const response = await this.meCreateMyWalletV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meDeleteMySubscriptionV1Raw(requestParameters: MeDeleteMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meDeleteMySubscriptionV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSubscriptionDtoFromJSON(jsonValue));
    }

    /**
     */
    async meDeleteMySubscriptionV1(requestParameters: MeDeleteMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto> {
        const response = await this.meDeleteMySubscriptionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMeV1Raw(requestParameters: MeFindMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicMeDto>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicMeDtoFromJSON(jsonValue));
    }

    /**
     */
    async meFindMeV1(requestParameters: MeFindMeV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicMeDto> {
        const response = await this.meFindMeV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyAddressV1Raw(requestParameters: MeFindMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicAddressDto>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling meFindMyAddressV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/addresses/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicAddressDtoFromJSON(jsonValue));
    }

    /**
     */
    async meFindMyAddressV1(requestParameters: MeFindMyAddressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicAddressDto> {
        const response = await this.meFindMyAddressV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyAddressesV1Raw(requestParameters: MeFindMyAddressesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicAddressDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/addresses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicAddressDtoFromJSON));
    }

    /**
     */
    async meFindMyAddressesV1(requestParameters: MeFindMyAddressesV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicAddressDto>> {
        const response = await this.meFindMyAddressesV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyInvoicesV1Raw(requestParameters: MeFindMyInvoicesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicInvoiceWithOrderAndItemsDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/invoices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicInvoiceWithOrderAndItemsDtoFromJSON));
    }

    /**
     */
    async meFindMyInvoicesV1(requestParameters: MeFindMyInvoicesV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicInvoiceWithOrderAndItemsDto>> {
        const response = await this.meFindMyInvoicesV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyOnboardingProgressV1Raw(requestParameters: MeFindMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOnboardingProgressDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/onboarding`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicOnboardingProgressDtoFromJSON));
    }

    /**
     */
    async meFindMyOnboardingProgressV1(requestParameters: MeFindMyOnboardingProgressV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOnboardingProgressDto>> {
        const response = await this.meFindMyOnboardingProgressV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyOrderTaxesV1Raw(requestParameters: MeFindMyOrderTaxesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicTaxItemDto>>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meFindMyOrderTaxesV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}/taxes`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicTaxItemDtoFromJSON));
    }

    /**
     */
    async meFindMyOrderTaxesV1(requestParameters: MeFindMyOrderTaxesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicTaxItemDto>> {
        const response = await this.meFindMyOrderTaxesV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * @deprecated
     */
    async meFindMyOrderV1Raw(requestParameters: MeFindMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meFindMyOrderV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     * 
     * @deprecated
     */
    async meFindMyOrderV1(requestParameters: MeFindMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meFindMyOrderV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyOrderV2Raw(requestParameters: MeFindMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meFindMyOrderV2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v2/users/me/orders/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithDetailsDtoFromJSON(jsonValue));
    }

    /**
     */
    async meFindMyOrderV2(requestParameters: MeFindMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto> {
        const response = await this.meFindMyOrderV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * @deprecated
     */
    async meFindMyOrdersV1Raw(requestParameters: MeFindMyOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderWithOfferDto>>> {
        const queryParameters: any = {};

        if (requestParameters['types'] != null) {
            queryParameters['types'] = requestParameters['types'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicOrderWithOfferDtoFromJSON));
    }

    /**
     * 
     * @deprecated
     */
    async meFindMyOrdersV1(requestParameters: MeFindMyOrdersV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderWithOfferDto>> {
        const response = await this.meFindMyOrdersV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyOrdersV2Raw(requestParameters: MeFindMyOrdersV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderDto>>> {
        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['step'] != null) {
            queryParameters['step'] = requestParameters['step'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v2/users/me/orders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicOrderDtoFromJSON));
    }

    /**
     */
    async meFindMyOrdersV2(requestParameters: MeFindMyOrdersV2Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderDto>> {
        const response = await this.meFindMyOrdersV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionActiveSimDetailsV1Raw(requestParameters: MeFindMySubscriptionActiveSimDetailsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSimDetailsDto>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionActiveSimDetailsV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/sims/active/details`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSimDetailsDtoFromJSON(jsonValue));
    }

    /**
     */
    async meFindMySubscriptionActiveSimDetailsV1(requestParameters: MeFindMySubscriptionActiveSimDetailsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSimDetailsDto> {
        const response = await this.meFindMySubscriptionActiveSimDetailsV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionActiveSimUsageV1Raw(requestParameters: MeFindMySubscriptionActiveSimUsageV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicVolumeUsageDto>>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionActiveSimUsageV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/sims/active/usage`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicVolumeUsageDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionActiveSimUsageV1(requestParameters: MeFindMySubscriptionActiveSimUsageV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicVolumeUsageDto>> {
        const response = await this.meFindMySubscriptionActiveSimUsageV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionChildrenV1Raw(requestParameters: MeFindMySubscriptionChildrenV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionWithOfferDto>>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionChildrenV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/children`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicSubscriptionWithOfferDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionChildrenV1(requestParameters: MeFindMySubscriptionChildrenV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionWithOfferDto>> {
        const response = await this.meFindMySubscriptionChildrenV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionOffersV1Raw(requestParameters: MeFindMySubscriptionOffersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOfferWithPlanWithVolumesDto>>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionOffersV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/offers`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicOfferWithPlanWithVolumesDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionOffersV1(requestParameters: MeFindMySubscriptionOffersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOfferWithPlanWithVolumesDto>> {
        const response = await this.meFindMySubscriptionOffersV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionOrdersV1Raw(requestParameters: MeFindMySubscriptionOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicOrderWithOfferDto>>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionOrdersV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/orders`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicOrderWithOfferDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionOrdersV1(requestParameters: MeFindMySubscriptionOrdersV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicOrderWithOfferDto>> {
        const response = await this.meFindMySubscriptionOrdersV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionPeriodsV1Raw(requestParameters: MeFindMySubscriptionPeriodsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionPeriodWithOfferDto>>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionPeriodsV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}/periods`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicSubscriptionPeriodWithOfferDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionPeriodsV1(requestParameters: MeFindMySubscriptionPeriodsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionPeriodWithOfferDto>> {
        const response = await this.meFindMySubscriptionPeriodsV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionV1Raw(requestParameters: MeFindMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionWithOfferDto>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meFindMySubscriptionV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSubscriptionWithOfferDtoFromJSON(jsonValue));
    }

    /**
     */
    async meFindMySubscriptionV1(requestParameters: MeFindMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionWithOfferDto> {
        const response = await this.meFindMySubscriptionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMySubscriptionsV1Raw(requestParameters: MeFindMySubscriptionsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicSubscriptionWithOfferDto>>> {
        const queryParameters: any = {};

        if (requestParameters['baseOnly'] != null) {
            queryParameters['baseOnly'] = requestParameters['baseOnly'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicSubscriptionWithOfferDtoFromJSON));
    }

    /**
     */
    async meFindMySubscriptionsV1(requestParameters: MeFindMySubscriptionsV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicSubscriptionWithOfferDto>> {
        const response = await this.meFindMySubscriptionsV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyWalletCertificatesV1Raw(requestParameters: MeFindMyWalletCertificatesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicCertificateDto>>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meFindMyWalletCertificatesV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}/certificates`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicCertificateDtoFromJSON));
    }

    /**
     */
    async meFindMyWalletCertificatesV1(requestParameters: MeFindMyWalletCertificatesV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicCertificateDto>> {
        const response = await this.meFindMyWalletCertificatesV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyWalletTokensV1Raw(requestParameters: MeFindMyWalletTokensV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicTokenBalanceDto>>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meFindMyWalletTokensV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}/tokens`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicTokenBalanceDtoFromJSON));
    }

    /**
     */
    async meFindMyWalletTokensV1(requestParameters: MeFindMyWalletTokensV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicTokenBalanceDto>> {
        const response = await this.meFindMyWalletTokensV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meFindMyWalletsV1Raw(requestParameters: MeFindMyWalletsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicWalletDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicWalletDtoFromJSON));
    }

    /**
     */
    async meFindMyWalletsV1(requestParameters: MeFindMyWalletsV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicWalletDto>> {
        const response = await this.meFindMyWalletsV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meGetCreditBalanceV1Raw(requestParameters: MeGetCreditBalanceV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/credit-balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async meGetCreditBalanceV1(requestParameters: MeGetCreditBalanceV1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.meGetCreditBalanceV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meGetMySigningRequestV1Raw(requestParameters: MeGetMySigningRequestV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSigningRequestDto>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meGetMySigningRequestV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}/validate`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSigningRequestDtoFromJSON(jsonValue));
    }

    /**
     */
    async meGetMySigningRequestV1(requestParameters: MeGetMySigningRequestV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSigningRequestDto> {
        const response = await this.meGetMySigningRequestV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meGetMyWalletTokenHistoryV1Raw(requestParameters: MeGetMyWalletTokenHistoryV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicTokenHistoryDto>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meGetMyWalletTokenHistoryV1().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling meGetMyWalletTokenHistoryV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['days'] != null) {
            queryParameters['days'] = requestParameters['days'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}/tokens/{token}/history`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters['token']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicTokenHistoryDtoFromJSON(jsonValue));
    }

    /**
     */
    async meGetMyWalletTokenHistoryV1(requestParameters: MeGetMyWalletTokenHistoryV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicTokenHistoryDto> {
        const response = await this.meGetMyWalletTokenHistoryV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUncancelMySubscriptionV1Raw(requestParameters: MeUncancelMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meUncancelMySubscriptionV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSubscriptionDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUncancelMySubscriptionV1(requestParameters: MeUncancelMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto> {
        const response = await this.meUncancelMySubscriptionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMeV1Raw(requestParameters: MeUpdateMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSessionTokensDto>> {
        if (requestParameters['updateMeDto'] == null) {
            throw new runtime.RequiredError(
                'updateMeDto',
                'Required parameter "updateMeDto" was null or undefined when calling meUpdateMeV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMeDtoToJSON(requestParameters['updateMeDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSessionTokensDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMeV1(requestParameters: MeUpdateMeV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSessionTokensDto> {
        const response = await this.meUpdateMeV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMyOnboardingProgressV1Raw(requestParameters: MeUpdateMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['updateMyOnboardingProgressDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOnboardingProgressDto',
                'Required parameter "updateMyOnboardingProgressDto" was null or undefined when calling meUpdateMyOnboardingProgressV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/onboarding`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOnboardingProgressDtoToJSON(requestParameters['updateMyOnboardingProgressDto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async meUpdateMyOnboardingProgressV1(requestParameters: MeUpdateMyOnboardingProgressV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.meUpdateMyOnboardingProgressV1Raw(requestParameters, initOverrides);
    }

    /**
     */
    async meUpdateMyOrderSimSelectionV1Raw(requestParameters: MeUpdateMyOrderSimSelectionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderSimSelectionV1().'
            );
        }

        if (requestParameters['updateMyOrderStepAttachSimDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderStepAttachSimDto',
                'Required parameter "updateMyOrderStepAttachSimDto" was null or undefined when calling meUpdateMyOrderSimSelectionV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}/sim-selection`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderStepAttachSimDtoToJSON(requestParameters['updateMyOrderStepAttachSimDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMyOrderSimSelectionV1(requestParameters: MeUpdateMyOrderSimSelectionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meUpdateMyOrderSimSelectionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMyOrderStepAttachSimV1Raw(requestParameters: MeUpdateMyOrderStepAttachSimV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderStepAttachSimV1().'
            );
        }

        if (requestParameters['stepId'] == null) {
            throw new runtime.RequiredError(
                'stepId',
                'Required parameter "stepId" was null or undefined when calling meUpdateMyOrderStepAttachSimV1().'
            );
        }

        if (requestParameters['updateMyOrderStepAttachSimDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderStepAttachSimDto',
                'Required parameter "updateMyOrderStepAttachSimDto" was null or undefined when calling meUpdateMyOrderStepAttachSimV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}/steps/ATTACH_SIM/{stepId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))).replace(`{${"stepId"}}`, encodeURIComponent(String(requestParameters['stepId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderStepAttachSimDtoToJSON(requestParameters['updateMyOrderStepAttachSimDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMyOrderStepAttachSimV1(requestParameters: MeUpdateMyOrderStepAttachSimV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meUpdateMyOrderStepAttachSimV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMyOrderStepSignV1Raw(requestParameters: MeUpdateMyOrderStepSignV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderStepSignV1().'
            );
        }

        if (requestParameters['updateMyOrderStepSignDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderStepSignDto',
                'Required parameter "updateMyOrderStepSignDto" was null or undefined when calling meUpdateMyOrderStepSignV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}/steps/current/SIGN`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderStepSignDtoToJSON(requestParameters['updateMyOrderStepSignDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithDetailsDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMyOrderStepSignV1(requestParameters: MeUpdateMyOrderStepSignV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto> {
        const response = await this.meUpdateMyOrderStepSignV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * @deprecated
     */
    async meUpdateMyOrderV1Raw(requestParameters: MeUpdateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderV1().'
            );
        }

        if (requestParameters['updateMyOrderDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderDto',
                'Required parameter "updateMyOrderDto" was null or undefined when calling meUpdateMyOrderV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/orders/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderDtoToJSON(requestParameters['updateMyOrderDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     * 
     * @deprecated
     */
    async meUpdateMyOrderV1(requestParameters: MeUpdateMyOrderV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meUpdateMyOrderV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * @deprecated
     */
    async meUpdateMyOrderV2Raw(requestParameters: MeUpdateMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithOfferDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderV2().'
            );
        }

        if (requestParameters['updateMyOrderV2Dto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderV2Dto',
                'Required parameter "updateMyOrderV2Dto" was null or undefined when calling meUpdateMyOrderV2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v2/users/me/orders/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderV2DtoToJSON(requestParameters['updateMyOrderV2Dto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithOfferDtoFromJSON(jsonValue));
    }

    /**
     * 
     * @deprecated
     */
    async meUpdateMyOrderV2(requestParameters: MeUpdateMyOrderV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithOfferDto> {
        const response = await this.meUpdateMyOrderV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMyOrderV3Raw(requestParameters: MeUpdateMyOrderV3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicOrderWithDetailsDto>> {
        if (requestParameters['orderId'] == null) {
            throw new runtime.RequiredError(
                'orderId',
                'Required parameter "orderId" was null or undefined when calling meUpdateMyOrderV3().'
            );
        }

        if (requestParameters['updateMyOrderV2Dto'] == null) {
            throw new runtime.RequiredError(
                'updateMyOrderV2Dto',
                'Required parameter "updateMyOrderV2Dto" was null or undefined when calling meUpdateMyOrderV3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v3/users/me/orders/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(requestParameters['orderId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyOrderV2DtoToJSON(requestParameters['updateMyOrderV2Dto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicOrderWithDetailsDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMyOrderV3(requestParameters: MeUpdateMyOrderV3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicOrderWithDetailsDto> {
        const response = await this.meUpdateMyOrderV3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMySubscriptionV1Raw(requestParameters: MeUpdateMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicSubscriptionDto>> {
        if (requestParameters['subId'] == null) {
            throw new runtime.RequiredError(
                'subId',
                'Required parameter "subId" was null or undefined when calling meUpdateMySubscriptionV1().'
            );
        }

        if (requestParameters['updateMySubscriptionDto'] == null) {
            throw new runtime.RequiredError(
                'updateMySubscriptionDto',
                'Required parameter "updateMySubscriptionDto" was null or undefined when calling meUpdateMySubscriptionV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/subscriptions/{subId}`.replace(`{${"subId"}}`, encodeURIComponent(String(requestParameters['subId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMySubscriptionDtoToJSON(requestParameters['updateMySubscriptionDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicSubscriptionDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMySubscriptionV1(requestParameters: MeUpdateMySubscriptionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicSubscriptionDto> {
        const response = await this.meUpdateMySubscriptionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meUpdateMyWalletV1Raw(requestParameters: MeUpdateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicWalletDto>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meUpdateMyWalletV1().'
            );
        }

        if (requestParameters['updateMyWalletDto'] == null) {
            throw new runtime.RequiredError(
                'updateMyWalletDto',
                'Required parameter "updateMyWalletDto" was null or undefined when calling meUpdateMyWalletV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMyWalletDtoToJSON(requestParameters['updateMyWalletDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicWalletDtoFromJSON(jsonValue));
    }

    /**
     */
    async meUpdateMyWalletV1(requestParameters: MeUpdateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicWalletDto> {
        const response = await this.meUpdateMyWalletV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async meValidateMyWalletV1Raw(requestParameters: MeValidateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['walletIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'walletIdOrAddress',
                'Required parameter "walletIdOrAddress" was null or undefined when calling meValidateMyWalletV1().'
            );
        }

        if (requestParameters['validateMyWalletDto'] == null) {
            throw new runtime.RequiredError(
                'validateMyWalletDto',
                'Required parameter "validateMyWalletDto" was null or undefined when calling meValidateMyWalletV1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthProvider'] != null) {
            headerParameters['x-auth-provider'] = String(requestParameters['xAuthProvider']);
        }

        if (requestParameters['xAuthStrategy'] != null) {
            headerParameters['x-auth-strategy'] = String(requestParameters['xAuthStrategy']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/users/me/wallets/{walletIdOrAddress}/validate`.replace(`{${"walletIdOrAddress"}}`, encodeURIComponent(String(requestParameters['walletIdOrAddress']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValidateMyWalletDtoToJSON(requestParameters['validateMyWalletDto']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async meValidateMyWalletV1(requestParameters: MeValidateMyWalletV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.meValidateMyWalletV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
